v2.0版本：
C++ Posix ThreadPool 需要优化的问题：
1. pthread_create可能存在返回了，但是线程还没创建完毕的情况，这样可能导致任务过多，但线程不够用的情况。
    解决思路：后续需要优化成只能创建完线程才让自己封装的create函数(不是系统函数pthread_create)返回。

2. 因调整线程而退出的线程，是没有完全回收掉资源的(threadpool_thread函数中)，这样当服务器长时间运行半年或者一年，就会出现资源浪费比较严重的问题。
    解决思路：参考C++11线程池，可以使用一个垃圾队列对其进行回收。
但目前这两个问题都不算是严重的问题，可以忽略，或者不使用带调整线程的线程池也行。

3. 虚拟内存占用过大，一个小时作用占用15g左右，目前猜测可能与第2点有关。然后我就去测试之前未添加调整线程的代码，虚拟内存保持稳定，基
本是600M左右，而添加之后占用非常大，所以基本确定是添加调整线程代码后导致的，后面需要优化，目前还是可以忽略的。或者可以写个小测试代码。

关于虚拟内存过大的，可以从以下文章深入检查。链接用时去掉\.
https://blog.csdn.net/chen19870707/article/details/43202679?ops_request_misc=%257B%2522request%255Fid%2522%253A%252216219116 \
7616780264099994%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=162191167616780264099994&biz_id=0&ut \
m_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-21-43202679.fi \
rst_rank_v2_pc_rank_v29&utm_term=%E7%A8%8B%E5%BA%8F%E5%8D%A0%E7%94%A8%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%A4%A7&spm=1018.2226.3001.4187

v3.0版本：
1. 优化2.0的2和3的问题。将普通数组换成vector数组，再增加一个垃圾队列去回收因调整线程而退出的线程资源，一回收后，虚拟内存不再变大，由此可见确实是问题2导致的。
    注意，一开始我直接使用普通数组去搭配垃圾队列去回收，但是因为在调用alive中的kill函数时，导致段错误，原因是被join后的线程，再调用kill函数去发信号会导致段错误，
    因为_t实际是一个指针，当线程pthread的内存被回收后，就不能再访问，也就说不能再调用kill，否则这是不安全的。
    所以后面没再使用普通数组而是使用动态数组vector去作为线程数组。
优化建议：
    1）将线程数组换成map<pthread_t, ThreadItem>类型存储，避免for遍历，增加效率
    2）减少例如忙线程锁等变量，使代码变得简洁。